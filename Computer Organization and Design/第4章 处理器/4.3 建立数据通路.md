![图 7](../../images/6a1634306b5b513ff28e7bda81a33c3c522e79ce822ce0686add4a4cce304489.png)  
![图 8](../../images/04f061a7e383a31044c07268440ec0838f10a2223120b88e614237fccc2f515d.png)  
执行任意一条指令，首先从存储器中取出指令，再增加程序计数器的值（向后移动四个字节）使其指向下一条指令
![图 9](../../images/b86882b48c03e9e49a66a6b1d58a89ee38e7dbb4b777e84e95e34f5d98540315.png)  
![图 10](../../images/054652fb89f17388903d7257c09315674f75ff5e874c02f0c508640995375939.png) 
每条R型指令需要从寄存器堆中读出两个数据字，再写入一个数据字
读数据时，需要
* 1个输入：指定要读的寄存器号
* 1个输出：从寄存器堆读出的数据

写数据时，需要
* 2个输入：要写的寄存器号和要写入寄存器的数据
* 写信号受到写控制信号控制

![图 11](../../images/4817e7a1ba19bb6cd834a25d8d25d6892c91b9203e3deb1a8845cd1496d57d1c.png)  
ALU读取两个64位输入并产生一个64位输出，还有一个1位输出指出其结果是否为0

存取指令通过将基址寄存器与指令中包含的12位有符号偏移量相加得到存储器地址，还要在寄存器中读出/写入要存储/读取的数据
![图 12](../../images/051c7dbfa5923cbaef1e0bf640d541a39bf22e7b660a2e197af7f1fbc2721913.png)  
![图 13](../../images/e1521d2d502f2e4f93727fdc717b9bfe7a46fa4483fd9c1b53b239752a58df3b.png)  

beg指令使用两个寄存器比较是否相等，并使用一个12位偏移量计算分支指令所在地址的分支目标地址
![图 14](../../images/f7c18dff469a653901dbf01b900be672d19f36c3d9f630c68681e326b3a97078.png)  
![![图 14](../../images/f7c18dff469a653901dbf01b900be672d19f36c3d9f630c68681e326b3a97078.png)  
 1](../../images/65367034192874474237cf5c8c2f94cdb6bc774b89ef153c50b64502a7b60919.png)  
![图 16](../../images/5b56416db962686d55be7888c72b6301edc731110d70997e792fcd6877ee7092.png)  

## 建立一个简单的数据通路
![图 17](../../images/73162ffb59a5f6bb043ee9cb58b0c96e8fdcff9afcaf5234378f5f460589fafd.png)  
![图 18](../../images/1e1de66cdb06cfb9186d92ada6bbd4c4f1f2da986826e5ab328368a149c8231b.png)  
把取指令数据通路、R型指令和存储类指令数据通路、分支指令数据通路合并：
![图 19](../../images/ebe928cfe273af38befb71c39f3733ead8b9d6f4d1eb99c96eb8216dddc48162.png)  
